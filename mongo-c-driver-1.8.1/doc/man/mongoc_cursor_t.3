.\" Man page generated from reStructuredText.
.
.TH "MONGOC_CURSOR_T" "3" "Oct 11, 2017" "1.8.1" "MongoDB C Driver"
.SH NAME
mongoc_cursor_t \- mongoc_cursor_t
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.sp
Client\-side cursor abstraction
.SH SYNOPSIS
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
typedef struct _mongoc_cursor_t mongoc_cursor_t;
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBmongoc_cursor_t\fP provides access to a MongoDB query cursor.
It wraps up the wire protocol negotiation required to initiate a query and retrieve an unknown number of documents.
.sp
Cursors are lazy, meaning that no network traffic occurs until the first call to \fBmongoc_cursor_next()\fP\&.
.sp
At that point we can:
.INDENT 0.0
.IP \(bu 2
Determine which host weâ€™ve connected to with \fBmongoc_cursor_get_host()\fP\&.
.IP \(bu 2
Retrieve more records with repeated calls to \fBmongoc_cursor_next()\fP\&.
.IP \(bu 2
Clone a query to repeat execution at a later point with \fBmongoc_cursor_clone()\fP\&.
.IP \(bu 2
Test for errors with \fBmongoc_cursor_error()\fP\&.
.UNINDENT
.SH THREAD SAFETY
.sp
\fBmongoc_cursor_t\fP is \fINOT\fP thread safe. It may only be used from the thread it was created from.
.SH EXAMPLE
Query MongoDB and iterate results.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
/* gcc example\-client.c \-o example\-client $(pkg\-config \-\-cflags \-\-libs
 * libmongoc\-1.0) */

/* ./example\-client [CONNECTION_STRING [COLLECTION_NAME]] */

#include <mongoc.h>
#include <stdio.h>
#include <stdlib.h>

int
main (int argc, char *argv[])
{
   mongoc_client_t *client;
   mongoc_collection_t *collection;
   mongoc_cursor_t *cursor;
   bson_error_t error;
   const bson_t *doc;
   const char *uristr = "mongodb://127.0.0.1/?appname=client\-example";
   const char *collection_name = "test";
   bson_t query;
   char *str;

   mongoc_init ();

   if (argc > 1) {
      uristr = argv[1];
   }

   if (argc > 2) {
      collection_name = argv[2];
   }

   client = mongoc_client_new (uristr);

   if (!client) {
      fprintf (stderr, "Failed to parse URI.\en");
      return EXIT_FAILURE;
   }

   mongoc_client_set_error_api (client, 2);

   bson_init (&query);

#if 0
   bson_append_utf8 (&query, "hello", \-1, "world", \-1);
#endif

   collection = mongoc_client_get_collection (client, "test", collection_name);
   cursor = mongoc_collection_find_with_opts (
      collection,
      &query,
      NULL,  /* additional options */
      NULL); /* read prefs, NULL for default */

   while (mongoc_cursor_next (cursor, &doc)) {
      str = bson_as_canonical_extended_json (doc, NULL);
      fprintf (stdout, "%s\en", str);
      bson_free (str);
   }

   if (mongoc_cursor_error (cursor, &error)) {
      fprintf (stderr, "Cursor Failure: %s\en", error.message);
      return EXIT_FAILURE;
   }

   bson_destroy (&query);
   mongoc_cursor_destroy (cursor);
   mongoc_collection_destroy (collection);
   mongoc_client_destroy (client);

   mongoc_cleanup ();

   return EXIT_SUCCESS;
}

.ft P
.fi
.UNINDENT
.UNINDENT
.SH AUTHOR
MongoDB, Inc
.SH COPYRIGHT
2017, MongoDB, Inc
.\" Generated by docutils manpage writer.
.
